--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:SM::Flow::P 
  body: Debugger.start(options) -&gt; bool Debugger.start(options) { ... } -&gt; obj
- !ruby/struct:SM::Flow::P 
  body: If it's called without a block it returns <tt>true</tt>, unless debugger was already started. If a block is given, it starts debugger and yields to block. When the block is finished executing it stops the debugger with Debugger.stop method.
- !ruby/struct:SM::Flow::P 
  body: "If a block is given, it starts debugger and yields to block. When the block is finished executing it stops the debugger with Debugger.stop method. Inside the block you will probably want to have a call to Debugger.debugger. For example:"
- !ruby/struct:SM::Flow::VERB 
  body: "    Debugger.start{debugger; foo}  # Stop inside of foo\n"
- !ruby/struct:SM::Flow::P 
  body: Also, ruby-debug only allows one invocation of debugger at a time; nested Debugger.start's have no effect and you can't use this inside the debugger itself.
- !ruby/struct:SM::Flow::P 
  body: <em>Note that if you want to stop debugger, you must call Debugger.stop as many time as you called Debugger.start method.</em>
- !ruby/struct:SM::Flow::P 
  body: <tt>options</tt> is a hash used to set various debugging options. Set :init true if you want to save ARGV and some variables which make a debugger restart possible. Only the first time :init is set true will values get set. Since ARGV is saved, you should make sure it hasn't been changed before the (first) call. Set :post_mortem true if you want to enter post-mortem debugging on an uncaught exception. Once post-mortem debugging is set, it can't be unset.
full_name: Debugger#start
is_singleton: false
name: start
params: (options={}, &block)
visibility: public
